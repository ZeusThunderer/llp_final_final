/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "nt_structs_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_DataType_(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case DATA_TYPE__INT_TYPE:return "DATA_TYPE__INT_TYPE";
  case DATA_TYPE__FLOAT_TYPE:return "DATA_TYPE__FLOAT_TYPE";
  case DATA_TYPE__STRING_TYPE:return "DATA_TYPE__STRING_TYPE";
  case DATA_TYPE__BOOL_TYPE:return "DATA_TYPE__BOOL_TYPE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_QueryType_(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case QUERY_TYPE__CREATE_STMT:return "QUERY_TYPE__CREATE_STMT";
  case QUERY_TYPE__DROP_STMT:return "QUERY_TYPE__DROP_STMT";
  case QUERY_TYPE__SELECT_STMT:return "QUERY_TYPE__SELECT_STMT";
  case QUERY_TYPE__UPDATE_STMT:return "QUERY_TYPE__UPDATE_STMT";
  case QUERY_TYPE__INSERT_STMT:return "QUERY_TYPE__INSERT_STMT";
  case QUERY_TYPE__DELETE_STMT:return "QUERY_TYPE__DELETE_STMT";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_LogicalOperator_(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case LOGICAL_OPERATOR__AND_OP:return "LOGICAL_OPERATOR__AND_OP";
  case LOGICAL_OPERATOR__OR_OP:return "LOGICAL_OPERATOR__OR_OP";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_CompType_(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case COMP_TYPE__EQUALS_COMP:return "COMP_TYPE__EQUALS_COMP";
  case COMP_TYPE__NOT_EQUALS_COMP:return "COMP_TYPE__NOT_EQUALS_COMP";
  case COMP_TYPE__GREATER_COMP:return "COMP_TYPE__GREATER_COMP";
  case COMP_TYPE__LESS_COMP:return "COMP_TYPE__LESS_COMP";
  case COMP_TYPE__GREATER_EQUALS_COMP:return "COMP_TYPE__GREATER_EQUALS_COMP";
  case COMP_TYPE__LESS_EQUALS_COMP:return "COMP_TYPE__LESS_EQUALS_COMP";
  case COMP_TYPE__LIKE_COMP:return "COMP_TYPE__LIKE_COMP";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_Status_(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case STATUS__OK:return "STATUS__OK";
  case STATUS__TABLE_NOT_FOUND:return "STATUS__TABLE_NOT_FOUND";
  case STATUS__BAD_REQUEST:return "STATUS__BAD_REQUEST";
  case STATUS__SERVER_ERROR:return "STATUS__SERVER_ERROR";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _Cell_Properties
{
  PROP_CELL__0,
  PROP_CELL__INTEGER,
  PROP_CELL__DBL,
  PROP_CELL__BL,
  PROP_CELL__STR
};

/* reads a cell_ object */
static gint32
cell__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Cell_ * this_object = CELL_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->integer, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_integer = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->dbl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_dbl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->bl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_bl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->str != NULL)
          {
            g_free(this_object->str);
            this_object->str = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->str, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_str = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
cell__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Cell_ * this_object = CELL_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Cell_", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_integer == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "integer", T_I64, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->integer, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_dbl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "dbl", T_DOUBLE, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->dbl, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_bl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "bl", T_BOOL, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->bl, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_str == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "str", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->str, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
cell__set_property (GObject *object,
                    guint property_id,
                    const GValue *value,
                    GParamSpec *pspec)
{
  Cell_ *self = CELL_ (object);

  switch (property_id)
  {
    case PROP_CELL__INTEGER:
      self->integer = g_value_get_int64 (value);
      self->__isset_integer = TRUE;
      break;

    case PROP_CELL__DBL:
      self->dbl = g_value_get_double (value);
      self->__isset_dbl = TRUE;
      break;

    case PROP_CELL__BL:
      self->bl = g_value_get_boolean (value);
      self->__isset_bl = TRUE;
      break;

    case PROP_CELL__STR:
      if (self->str != NULL)
        g_free (self->str);
      self->str = g_value_dup_string (value);
      self->__isset_str = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
cell__get_property (GObject *object,
                    guint property_id,
                    GValue *value,
                    GParamSpec *pspec)
{
  Cell_ *self = CELL_ (object);

  switch (property_id)
  {
    case PROP_CELL__INTEGER:
      g_value_set_int64 (value, self->integer);
      break;

    case PROP_CELL__DBL:
      g_value_set_double (value, self->dbl);
      break;

    case PROP_CELL__BL:
      g_value_set_boolean (value, self->bl);
      break;

    case PROP_CELL__STR:
      g_value_set_string (value, self->str);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
cell__instance_init (Cell_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->integer = 0;
  object->__isset_integer = FALSE;
  object->dbl = 0;
  object->__isset_dbl = FALSE;
  object->bl = 0;
  object->__isset_bl = FALSE;
  object->str = NULL;
  object->__isset_str = FALSE;
}

static void 
cell__finalize (GObject *object)
{
  Cell_ *tobject = CELL_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->str != NULL)
  {
    g_free(tobject->str);
    tobject->str = NULL;
  }
}

static void
cell__class_init (Cell_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = cell__read;
  struct_class->write = cell__write;

  gobject_class->finalize = cell__finalize;
  gobject_class->get_property = cell__get_property;
  gobject_class->set_property = cell__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CELL__INTEGER,
     g_param_spec_int64 ("integer",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CELL__DBL,
     g_param_spec_double ("dbl",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CELL__BL,
     g_param_spec_boolean ("bl",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CELL__STR,
     g_param_spec_string ("str",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
cell__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Cell_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) cell__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Cell_),
      0, /* n_preallocs */
      (GInstanceInitFunc) cell__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Cell_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _Column_Properties
{
  PROP_COLUMN__0,
  PROP_COLUMN__COLUMN_NAME,
  PROP_COLUMN__DATA_TYPE,
  PROP_COLUMN__SIZE
};

/* reads a column_ object */
static gint32
column__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Column_ * this_object = COLUMN_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->column_name != NULL)
          {
            g_free(this_object->column_name);
            this_object->column_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->column_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_column_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast0;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->data_type = (DataType_)ecast0;
          this_object->__isset_data_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->size, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
column__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Column_ * this_object = COLUMN_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Column_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column_name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->column_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data_type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->data_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "size", T_I16, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
column__set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  Column_ *self = COLUMN_ (object);

  switch (property_id)
  {
    case PROP_COLUMN__COLUMN_NAME:
      if (self->column_name != NULL)
        g_free (self->column_name);
      self->column_name = g_value_dup_string (value);
      self->__isset_column_name = TRUE;
      break;

    case PROP_COLUMN__DATA_TYPE:
      self->data_type = g_value_get_int (value);
      self->__isset_data_type = TRUE;
      break;

    case PROP_COLUMN__SIZE:
      self->size = g_value_get_int (value);
      self->__isset_size = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
column__get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  Column_ *self = COLUMN_ (object);

  switch (property_id)
  {
    case PROP_COLUMN__COLUMN_NAME:
      g_value_set_string (value, self->column_name);
      break;

    case PROP_COLUMN__DATA_TYPE:
      g_value_set_int (value, self->data_type);
      break;

    case PROP_COLUMN__SIZE:
      g_value_set_int (value, self->size);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
column__instance_init (Column_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->column_name = NULL;
  object->__isset_column_name = FALSE;
  object->__isset_data_type = FALSE;
  object->size = 0;
  object->__isset_size = FALSE;
}

static void 
column__finalize (GObject *object)
{
  Column_ *tobject = COLUMN_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->column_name != NULL)
  {
    g_free(tobject->column_name);
    tobject->column_name = NULL;
  }
}

static void
column__class_init (Column_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = column__read;
  struct_class->write = column__write;

  gobject_class->finalize = column__finalize;
  gobject_class->get_property = column__get_property;
  gobject_class->set_property = column__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN__COLUMN_NAME,
     g_param_spec_string ("column_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN__DATA_TYPE,
     g_param_spec_int ("data_type",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN__SIZE,
     g_param_spec_int ("size",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));
}

GType
column__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Column_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) column__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Column_),
      0, /* n_preallocs */
      (GInstanceInitFunc) column__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Column_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _CreateStmt_Properties
{
  PROP_CREATE_STMT__0,
  PROP_CREATE_STMT__COLS,
  PROP_CREATE_STMT__TBL_NAME
};

/* reads a create_stmt_ object */
static gint32
create_stmt__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CreateStmt_ * this_object = CREATE_STMT_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Column_ * _elem1 = NULL;
              if ( _elem1 != NULL)
              {
                g_object_unref (_elem1);
              }
              _elem1 = g_object_new (TYPE_COLUMN_, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem1), protocol, error)) < 0)
              {
                g_object_unref (_elem1);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->cols, _elem1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_cols = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->tblName != NULL)
          {
            g_free(this_object->tblName);
            this_object->tblName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->tblName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tblName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
create_stmt__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CreateStmt_ * this_object = CREATE_STMT_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CreateStmt_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cols", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i2;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->cols ? this_object->cols->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i2 = 0; i2 < (this_object->cols ? this_object->cols->len : 0); i2++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->cols, i2))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tblName", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->tblName, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
create_stmt__set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  CreateStmt_ *self = CREATE_STMT_ (object);

  switch (property_id)
  {
    case PROP_CREATE_STMT__COLS:
      if (self->cols != NULL)
        g_ptr_array_unref (self->cols);
      self->cols = g_value_dup_boxed (value);
      self->__isset_cols = TRUE;
      break;

    case PROP_CREATE_STMT__TBL_NAME:
      if (self->tblName != NULL)
        g_free (self->tblName);
      self->tblName = g_value_dup_string (value);
      self->__isset_tblName = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
create_stmt__get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  CreateStmt_ *self = CREATE_STMT_ (object);

  switch (property_id)
  {
    case PROP_CREATE_STMT__COLS:
      g_value_set_boxed (value, self->cols);
      break;

    case PROP_CREATE_STMT__TBL_NAME:
      g_value_set_string (value, self->tblName);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
create_stmt__instance_init (CreateStmt_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cols = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_cols = FALSE;
  object->tblName = NULL;
  object->__isset_tblName = FALSE;
}

static void 
create_stmt__finalize (GObject *object)
{
  CreateStmt_ *tobject = CREATE_STMT_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->cols != NULL)
  {
    g_ptr_array_unref (tobject->cols);
    tobject->cols = NULL;
  }
  if (tobject->tblName != NULL)
  {
    g_free(tobject->tblName);
    tobject->tblName = NULL;
  }
}

static void
create_stmt__class_init (CreateStmt_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = create_stmt__read;
  struct_class->write = create_stmt__write;

  gobject_class->finalize = create_stmt__finalize;
  gobject_class->get_property = create_stmt__get_property;
  gobject_class->set_property = create_stmt__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CREATE_STMT__COLS,
     g_param_spec_boxed ("cols",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CREATE_STMT__TBL_NAME,
     g_param_spec_string ("tblName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
create_stmt__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CreateStmt_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) create_stmt__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CreateStmt_),
      0, /* n_preallocs */
      (GInstanceInitFunc) create_stmt__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CreateStmt_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _Val_Properties
{
  PROP_VAL__0,
  PROP_VAL__CELL,
  PROP_VAL__TYPE
};

/* reads a val_ object */
static gint32
val__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Val_ * this_object = VAL_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->cell), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_cell = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast3;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast3, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (DataType_)ecast3;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
val__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Val_ * this_object = VAL_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Val_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cell", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->cell), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
val__set_property (GObject *object,
                   guint property_id,
                   const GValue *value,
                   GParamSpec *pspec)
{
  Val_ *self = VAL_ (object);

  switch (property_id)
  {
    case PROP_VAL__CELL:
      if (self->cell != NULL)
        g_object_unref (self->cell);
      self->cell = g_value_dup_object (value);
      self->__isset_cell = TRUE;
      break;

    case PROP_VAL__TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
val__get_property (GObject *object,
                   guint property_id,
                   GValue *value,
                   GParamSpec *pspec)
{
  Val_ *self = VAL_ (object);

  switch (property_id)
  {
    case PROP_VAL__CELL:
      g_value_set_object (value, self->cell);
      break;

    case PROP_VAL__TYPE:
      g_value_set_int (value, self->type);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
val__instance_init (Val_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cell = g_object_new (TYPE_CELL_, NULL);
  object->__isset_cell = FALSE;
  object->__isset_type = FALSE;
}

static void 
val__finalize (GObject *object)
{
  Val_ *tobject = VAL_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->cell != NULL)
  {
    g_object_unref(tobject->cell);
    tobject->cell = NULL;
  }
}

static void
val__class_init (Val_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = val__read;
  struct_class->write = val__write;

  gobject_class->finalize = val__finalize;
  gobject_class->get_property = val__get_property;
  gobject_class->set_property = val__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_VAL__CELL,
     g_param_spec_object ("cell",
                         NULL,
                         NULL,
                         TYPE_CELL_,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_VAL__TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));
}

GType
val__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Val_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) val__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Val_),
      0, /* n_preallocs */
      (GInstanceInitFunc) val__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Val_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _ColVal_Properties
{
  PROP_COL_VAL__0,
  PROP_COL_VAL__COL,
  PROP_COL_VAL__VAL
};

/* reads a col_val_ object */
static gint32
col_val__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColVal_ * this_object = COL_VAL_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->col != NULL)
          {
            g_free(this_object->col);
            this_object->col = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->col, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_col = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->val), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_val = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
col_val__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColVal_ * this_object = COL_VAL_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColVal_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "col", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->col, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "val", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->val), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
col_val__set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  ColVal_ *self = COL_VAL_ (object);

  switch (property_id)
  {
    case PROP_COL_VAL__COL:
      if (self->col != NULL)
        g_free (self->col);
      self->col = g_value_dup_string (value);
      self->__isset_col = TRUE;
      break;

    case PROP_COL_VAL__VAL:
      if (self->val != NULL)
        g_object_unref (self->val);
      self->val = g_value_dup_object (value);
      self->__isset_val = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
col_val__get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  ColVal_ *self = COL_VAL_ (object);

  switch (property_id)
  {
    case PROP_COL_VAL__COL:
      g_value_set_string (value, self->col);
      break;

    case PROP_COL_VAL__VAL:
      g_value_set_object (value, self->val);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
col_val__instance_init (ColVal_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->col = NULL;
  object->__isset_col = FALSE;
  object->val = g_object_new (TYPE_VAL_, NULL);
  object->__isset_val = FALSE;
}

static void 
col_val__finalize (GObject *object)
{
  ColVal_ *tobject = COL_VAL_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->col != NULL)
  {
    g_free(tobject->col);
    tobject->col = NULL;
  }
  if (tobject->val != NULL)
  {
    g_object_unref(tobject->val);
    tobject->val = NULL;
  }
}

static void
col_val__class_init (ColVal_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = col_val__read;
  struct_class->write = col_val__write;

  gobject_class->finalize = col_val__finalize;
  gobject_class->get_property = col_val__get_property;
  gobject_class->set_property = col_val__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_COL_VAL__COL,
     g_param_spec_string ("col",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COL_VAL__VAL,
     g_param_spec_object ("val",
                         NULL,
                         NULL,
                         TYPE_VAL_,
                         G_PARAM_READWRITE));
}

GType
col_val__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ColVal_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) col_val__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ColVal_),
      0, /* n_preallocs */
      (GInstanceInitFunc) col_val__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ColVal_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _InsertStmt_Properties
{
  PROP_INSERT_STMT__0,
  PROP_INSERT_STMT__TBL_NAME,
  PROP_INSERT_STMT__ROWS
};

/* reads a insert_stmt_ object */
static gint32
insert_stmt__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  InsertStmt_ * this_object = INSERT_STMT_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tblName != NULL)
          {
            g_free(this_object->tblName);
            this_object->tblName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->tblName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tblName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GPtrArray * _elem4 = g_ptr_array_new_with_free_func (g_object_unref);
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  ColVal_ * _elem5 = NULL;
                  if ( _elem5 != NULL)
                  {
                    g_object_unref (_elem5);
                  }
                  _elem5 = g_object_new (TYPE_COL_VAL_, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem5), protocol, error)) < 0)
                  {
                    g_object_unref (_elem5);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (_elem4, _elem5);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_ptr_array_add (this_object->rows, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
insert_stmt__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  InsertStmt_ * this_object = INSERT_STMT_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "InsertStmt_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tblName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->tblName, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rows", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i6;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) (this_object->rows ? this_object->rows->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i6 = 0; i6 < (this_object->rows ? this_object->rows->len : 0); i6++)
    {
      {
        guint i7;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->rows, i6)) ? ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->rows, i6))->len : 0), error)) < 0)
          return -1;
        xfer += ret;
        for (i7 = 0; i7 < (((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->rows, i6)) ? ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->rows, i6))->len : 0); i7++)
        {
          if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->rows, i6)), i7))), protocol, error)) < 0)
            return -1;
          xfer += ret;

        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
insert_stmt__set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  InsertStmt_ *self = INSERT_STMT_ (object);

  switch (property_id)
  {
    case PROP_INSERT_STMT__TBL_NAME:
      if (self->tblName != NULL)
        g_free (self->tblName);
      self->tblName = g_value_dup_string (value);
      self->__isset_tblName = TRUE;
      break;

    case PROP_INSERT_STMT__ROWS:
      if (self->rows != NULL)
        g_ptr_array_unref (self->rows);
      self->rows = g_value_dup_boxed (value);
      self->__isset_rows = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
insert_stmt__get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  InsertStmt_ *self = INSERT_STMT_ (object);

  switch (property_id)
  {
    case PROP_INSERT_STMT__TBL_NAME:
      g_value_set_string (value, self->tblName);
      break;

    case PROP_INSERT_STMT__ROWS:
      g_value_set_boxed (value, self->rows);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
insert_stmt__instance_init (InsertStmt_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tblName = NULL;
  object->__isset_tblName = FALSE;
  object->rows = g_ptr_array_new_with_free_func ((GDestroyNotify) g_ptr_array_unref);
  object->__isset_rows = FALSE;
}

static void 
insert_stmt__finalize (GObject *object)
{
  InsertStmt_ *tobject = INSERT_STMT_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tblName != NULL)
  {
    g_free(tobject->tblName);
    tobject->tblName = NULL;
  }
  if (tobject->rows != NULL)
  {
    g_ptr_array_unref (tobject->rows);
    tobject->rows = NULL;
  }
}

static void
insert_stmt__class_init (InsertStmt_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = insert_stmt__read;
  struct_class->write = insert_stmt__write;

  gobject_class->finalize = insert_stmt__finalize;
  gobject_class->get_property = insert_stmt__get_property;
  gobject_class->set_property = insert_stmt__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_INSERT_STMT__TBL_NAME,
     g_param_spec_string ("tblName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_INSERT_STMT__ROWS,
     g_param_spec_boxed ("rows",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
insert_stmt__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (InsertStmt_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) insert_stmt__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (InsertStmt_),
      0, /* n_preallocs */
      (GInstanceInitFunc) insert_stmt__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "InsertStmt_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _DropStmt_Properties
{
  PROP_DROP_STMT__0,
  PROP_DROP_STMT__TBL_NAME
};

/* reads a drop_stmt_ object */
static gint32
drop_stmt__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DropStmt_ * this_object = DROP_STMT_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tblName != NULL)
          {
            g_free(this_object->tblName);
            this_object->tblName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->tblName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tblName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
drop_stmt__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DropStmt_ * this_object = DROP_STMT_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DropStmt_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tblName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->tblName, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
drop_stmt__set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  DropStmt_ *self = DROP_STMT_ (object);

  switch (property_id)
  {
    case PROP_DROP_STMT__TBL_NAME:
      if (self->tblName != NULL)
        g_free (self->tblName);
      self->tblName = g_value_dup_string (value);
      self->__isset_tblName = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
drop_stmt__get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  DropStmt_ *self = DROP_STMT_ (object);

  switch (property_id)
  {
    case PROP_DROP_STMT__TBL_NAME:
      g_value_set_string (value, self->tblName);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
drop_stmt__instance_init (DropStmt_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tblName = NULL;
  object->__isset_tblName = FALSE;
}

static void 
drop_stmt__finalize (GObject *object)
{
  DropStmt_ *tobject = DROP_STMT_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tblName != NULL)
  {
    g_free(tobject->tblName);
    tobject->tblName = NULL;
  }
}

static void
drop_stmt__class_init (DropStmt_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = drop_stmt__read;
  struct_class->write = drop_stmt__write;

  gobject_class->finalize = drop_stmt__finalize;
  gobject_class->get_property = drop_stmt__get_property;
  gobject_class->set_property = drop_stmt__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DROP_STMT__TBL_NAME,
     g_param_spec_string ("tblName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
drop_stmt__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DropStmt_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) drop_stmt__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DropStmt_),
      0, /* n_preallocs */
      (GInstanceInitFunc) drop_stmt__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DropStmt_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _FullColumnName_Properties
{
  PROP_FULL_COLUMN_NAME__0,
  PROP_FULL_COLUMN_NAME__ROW_NAME,
  PROP_FULL_COLUMN_NAME__COL_NAME
};

/* reads a full_column_name_ object */
static gint32
full_column_name__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  FullColumnName_ * this_object = FULL_COLUMN_NAME_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->row_name != NULL)
          {
            g_free(this_object->row_name);
            this_object->row_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->row_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_row_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->col_name != NULL)
          {
            g_free(this_object->col_name);
            this_object->col_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->col_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_col_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
full_column_name__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  FullColumnName_ * this_object = FULL_COLUMN_NAME_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FullColumnName_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row_name", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->row_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "col_name", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->col_name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
full_column_name__set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  FullColumnName_ *self = FULL_COLUMN_NAME_ (object);

  switch (property_id)
  {
    case PROP_FULL_COLUMN_NAME__ROW_NAME:
      if (self->row_name != NULL)
        g_free (self->row_name);
      self->row_name = g_value_dup_string (value);
      self->__isset_row_name = TRUE;
      break;

    case PROP_FULL_COLUMN_NAME__COL_NAME:
      if (self->col_name != NULL)
        g_free (self->col_name);
      self->col_name = g_value_dup_string (value);
      self->__isset_col_name = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
full_column_name__get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  FullColumnName_ *self = FULL_COLUMN_NAME_ (object);

  switch (property_id)
  {
    case PROP_FULL_COLUMN_NAME__ROW_NAME:
      g_value_set_string (value, self->row_name);
      break;

    case PROP_FULL_COLUMN_NAME__COL_NAME:
      g_value_set_string (value, self->col_name);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
full_column_name__instance_init (FullColumnName_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->row_name = NULL;
  object->__isset_row_name = FALSE;
  object->col_name = NULL;
  object->__isset_col_name = FALSE;
}

static void 
full_column_name__finalize (GObject *object)
{
  FullColumnName_ *tobject = FULL_COLUMN_NAME_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->row_name != NULL)
  {
    g_free(tobject->row_name);
    tobject->row_name = NULL;
  }
  if (tobject->col_name != NULL)
  {
    g_free(tobject->col_name);
    tobject->col_name = NULL;
  }
}

static void
full_column_name__class_init (FullColumnName_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = full_column_name__read;
  struct_class->write = full_column_name__write;

  gobject_class->finalize = full_column_name__finalize;
  gobject_class->get_property = full_column_name__get_property;
  gobject_class->set_property = full_column_name__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_FULL_COLUMN_NAME__ROW_NAME,
     g_param_spec_string ("row_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FULL_COLUMN_NAME__COL_NAME,
     g_param_spec_string ("col_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
full_column_name__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (FullColumnName_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) full_column_name__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (FullColumnName_),
      0, /* n_preallocs */
      (GInstanceInitFunc) full_column_name__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "FullColumnName_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _Condition_Properties
{
  PROP_CONDITION__0,
  PROP_CONDITION__COLUMN,
  PROP_CONDITION__COMP_TYPE,
  PROP_CONDITION__VALUE
};

/* reads a condition_ object */
static gint32
condition__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Condition_ * this_object = CONDITION_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->column), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_column = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast8;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp_type = (CompType_)ecast8;
          this_object->__isset_comp_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
condition__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Condition_ * this_object = CONDITION_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Condition_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->column), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comp_type", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
condition__set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  Condition_ *self = CONDITION_ (object);

  switch (property_id)
  {
    case PROP_CONDITION__COLUMN:
      if (self->column != NULL)
        g_object_unref (self->column);
      self->column = g_value_dup_object (value);
      self->__isset_column = TRUE;
      break;

    case PROP_CONDITION__COMP_TYPE:
      self->comp_type = g_value_get_int (value);
      self->__isset_comp_type = TRUE;
      break;

    case PROP_CONDITION__VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
condition__get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  Condition_ *self = CONDITION_ (object);

  switch (property_id)
  {
    case PROP_CONDITION__COLUMN:
      g_value_set_object (value, self->column);
      break;

    case PROP_CONDITION__COMP_TYPE:
      g_value_set_int (value, self->comp_type);
      break;

    case PROP_CONDITION__VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
condition__instance_init (Condition_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->column = g_object_new (TYPE_FULL_COLUMN_NAME_, NULL);
  object->__isset_column = FALSE;
  object->__isset_comp_type = FALSE;
  object->value = g_object_new (TYPE_VAL_, NULL);
  object->__isset_value = FALSE;
}

static void 
condition__finalize (GObject *object)
{
  Condition_ *tobject = CONDITION_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->column != NULL)
  {
    g_object_unref(tobject->column);
    tobject->column = NULL;
  }
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
condition__class_init (Condition_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = condition__read;
  struct_class->write = condition__write;

  gobject_class->finalize = condition__finalize;
  gobject_class->get_property = condition__get_property;
  gobject_class->set_property = condition__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CONDITION__COLUMN,
     g_param_spec_object ("column",
                         NULL,
                         NULL,
                         TYPE_FULL_COLUMN_NAME_,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONDITION__COMP_TYPE,
     g_param_spec_int ("comp_type",
                       NULL,
                       NULL,
                       0,
                       6,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CONDITION__VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_VAL_,
                         G_PARAM_READWRITE));
}

GType
condition__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Condition_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) condition__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Condition_),
      0, /* n_preallocs */
      (GInstanceInitFunc) condition__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Condition_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _CompoundCondition_Properties
{
  PROP_COMPOUND_CONDITION__0,
  PROP_COMPOUND_CONDITION__LEFT,
  PROP_COMPOUND_CONDITION__OP,
  PROP_COMPOUND_CONDITION__RIGHT
};

/* reads a compound_condition_ object */
static gint32
compound_condition__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CompoundCondition_ * this_object = COMPOUND_CONDITION_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->left), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_left = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast9;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast9, error)) < 0)
            return -1;
          xfer += ret;
          this_object->op = (LogicalOperator_)ecast9;
          this_object->__isset_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              CompoundCondition_ * _elem10 = NULL;
              if ( _elem10 != NULL)
              {
                g_object_unref (_elem10);
              }
              _elem10 = g_object_new (TYPE_COMPOUND_CONDITION_, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem10), protocol, error)) < 0)
              {
                g_object_unref (_elem10);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->right, _elem10);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_right = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
compound_condition__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CompoundCondition_ * this_object = COMPOUND_CONDITION_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CompoundCondition_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "left", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->left), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->op, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_right == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "right", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i11;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->right ? this_object->right->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i11 = 0; i11 < (this_object->right ? this_object->right->len : 0); i11++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->right, i11))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
compound_condition__set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  CompoundCondition_ *self = COMPOUND_CONDITION_ (object);

  switch (property_id)
  {
    case PROP_COMPOUND_CONDITION__LEFT:
      if (self->left != NULL)
        g_object_unref (self->left);
      self->left = g_value_dup_object (value);
      self->__isset_left = TRUE;
      break;

    case PROP_COMPOUND_CONDITION__OP:
      self->op = g_value_get_int (value);
      self->__isset_op = TRUE;
      break;

    case PROP_COMPOUND_CONDITION__RIGHT:
      if (self->right != NULL)
        g_ptr_array_unref (self->right);
      self->right = g_value_dup_boxed (value);
      self->__isset_right = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
compound_condition__get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  CompoundCondition_ *self = COMPOUND_CONDITION_ (object);

  switch (property_id)
  {
    case PROP_COMPOUND_CONDITION__LEFT:
      g_value_set_object (value, self->left);
      break;

    case PROP_COMPOUND_CONDITION__OP:
      g_value_set_int (value, self->op);
      break;

    case PROP_COMPOUND_CONDITION__RIGHT:
      g_value_set_boxed (value, self->right);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
compound_condition__instance_init (CompoundCondition_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->left = g_object_new (TYPE_CONDITION_, NULL);
  object->__isset_left = FALSE;
  object->__isset_op = FALSE;
  object->right = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_right = FALSE;
}

static void 
compound_condition__finalize (GObject *object)
{
  CompoundCondition_ *tobject = COMPOUND_CONDITION_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->left != NULL)
  {
    g_object_unref(tobject->left);
    tobject->left = NULL;
  }
  if (tobject->right != NULL)
  {
    g_ptr_array_unref (tobject->right);
    tobject->right = NULL;
  }
}

static void
compound_condition__class_init (CompoundCondition_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = compound_condition__read;
  struct_class->write = compound_condition__write;

  gobject_class->finalize = compound_condition__finalize;
  gobject_class->get_property = compound_condition__get_property;
  gobject_class->set_property = compound_condition__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_COMPOUND_CONDITION__LEFT,
     g_param_spec_object ("left",
                         NULL,
                         NULL,
                         TYPE_CONDITION_,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COMPOUND_CONDITION__OP,
     g_param_spec_int ("op",
                       NULL,
                       NULL,
                       0,
                       1,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COMPOUND_CONDITION__RIGHT,
     g_param_spec_boxed ("right",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
compound_condition__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CompoundCondition_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) compound_condition__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CompoundCondition_),
      0, /* n_preallocs */
      (GInstanceInitFunc) compound_condition__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CompoundCondition_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _Projection_Properties
{
  PROP_PROJECTION__0,
  PROP_PROJECTION__NEW_COL,
  PROP_PROJECTION__SRC
};

/* reads a projection_ object */
static gint32
projection__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Projection_ * this_object = PROJECTION_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->new_col != NULL)
          {
            g_free(this_object->new_col);
            this_object->new_col = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->new_col, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_new_col = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->src), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_src = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
projection__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Projection_ * this_object = PROJECTION_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Projection_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "new_col", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->new_col, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "src", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->src), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
projection__set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  Projection_ *self = PROJECTION_ (object);

  switch (property_id)
  {
    case PROP_PROJECTION__NEW_COL:
      if (self->new_col != NULL)
        g_free (self->new_col);
      self->new_col = g_value_dup_string (value);
      self->__isset_new_col = TRUE;
      break;

    case PROP_PROJECTION__SRC:
      if (self->src != NULL)
        g_object_unref (self->src);
      self->src = g_value_dup_object (value);
      self->__isset_src = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
projection__get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  Projection_ *self = PROJECTION_ (object);

  switch (property_id)
  {
    case PROP_PROJECTION__NEW_COL:
      g_value_set_string (value, self->new_col);
      break;

    case PROP_PROJECTION__SRC:
      g_value_set_object (value, self->src);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
projection__instance_init (Projection_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->new_col = NULL;
  object->__isset_new_col = FALSE;
  object->src = g_object_new (TYPE_FULL_COLUMN_NAME_, NULL);
  object->__isset_src = FALSE;
}

static void 
projection__finalize (GObject *object)
{
  Projection_ *tobject = PROJECTION_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->new_col != NULL)
  {
    g_free(tobject->new_col);
    tobject->new_col = NULL;
  }
  if (tobject->src != NULL)
  {
    g_object_unref(tobject->src);
    tobject->src = NULL;
  }
}

static void
projection__class_init (Projection_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = projection__read;
  struct_class->write = projection__write;

  gobject_class->finalize = projection__finalize;
  gobject_class->get_property = projection__get_property;
  gobject_class->set_property = projection__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PROJECTION__NEW_COL,
     g_param_spec_string ("new_col",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PROJECTION__SRC,
     g_param_spec_object ("src",
                         NULL,
                         NULL,
                         TYPE_FULL_COLUMN_NAME_,
                         G_PARAM_READWRITE));
}

GType
projection__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Projection_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) projection__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Projection_),
      0, /* n_preallocs */
      (GInstanceInitFunc) projection__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Projection_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _SelectList_Properties
{
  PROP_SELECT_LIST__0,
  PROP_SELECT_LIST__ROW_NAME,
  PROP_SELECT_LIST__PROJS
};

/* reads a select_list_ object */
static gint32
select_list__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SelectList_ * this_object = SELECT_LIST_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->rowName != NULL)
          {
            g_free(this_object->rowName);
            this_object->rowName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->rowName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rowName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Projection_ * _elem12 = NULL;
              if ( _elem12 != NULL)
              {
                g_object_unref (_elem12);
              }
              _elem12 = g_object_new (TYPE_PROJECTION_, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem12), protocol, error)) < 0)
              {
                g_object_unref (_elem12);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->projs, _elem12);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_projs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
select_list__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SelectList_ * this_object = SELECT_LIST_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SelectList_", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_rowName == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "rowName", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->rowName, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_projs == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "projs", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i13;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->projs ? this_object->projs->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i13 = 0; i13 < (this_object->projs ? this_object->projs->len : 0); i13++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->projs, i13))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
select_list__set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  SelectList_ *self = SELECT_LIST_ (object);

  switch (property_id)
  {
    case PROP_SELECT_LIST__ROW_NAME:
      if (self->rowName != NULL)
        g_free (self->rowName);
      self->rowName = g_value_dup_string (value);
      self->__isset_rowName = TRUE;
      break;

    case PROP_SELECT_LIST__PROJS:
      if (self->projs != NULL)
        g_ptr_array_unref (self->projs);
      self->projs = g_value_dup_boxed (value);
      self->__isset_projs = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
select_list__get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  SelectList_ *self = SELECT_LIST_ (object);

  switch (property_id)
  {
    case PROP_SELECT_LIST__ROW_NAME:
      g_value_set_string (value, self->rowName);
      break;

    case PROP_SELECT_LIST__PROJS:
      g_value_set_boxed (value, self->projs);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
select_list__instance_init (SelectList_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->rowName = NULL;
  object->__isset_rowName = FALSE;
  object->projs = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_projs = FALSE;
}

static void 
select_list__finalize (GObject *object)
{
  SelectList_ *tobject = SELECT_LIST_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->rowName != NULL)
  {
    g_free(tobject->rowName);
    tobject->rowName = NULL;
  }
  if (tobject->projs != NULL)
  {
    g_ptr_array_unref (tobject->projs);
    tobject->projs = NULL;
  }
}

static void
select_list__class_init (SelectList_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = select_list__read;
  struct_class->write = select_list__write;

  gobject_class->finalize = select_list__finalize;
  gobject_class->get_property = select_list__get_property;
  gobject_class->set_property = select_list__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SELECT_LIST__ROW_NAME,
     g_param_spec_string ("rowName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SELECT_LIST__PROJS,
     g_param_spec_boxed ("projs",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
select_list__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SelectList_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) select_list__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SelectList_),
      0, /* n_preallocs */
      (GInstanceInitFunc) select_list__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SelectList_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _Join_Properties
{
  PROP_JOIN__0,
  PROP_JOIN__ROW_NAME,
  PROP_JOIN__TBL_NAME,
  PROP_JOIN__LEFT_COL,
  PROP_JOIN__RIGHT_COL
};

/* reads a join_ object */
static gint32
join__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Join_ * this_object = JOIN_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->rowName != NULL)
          {
            g_free(this_object->rowName);
            this_object->rowName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->rowName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rowName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->tblName != NULL)
          {
            g_free(this_object->tblName);
            this_object->tblName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->tblName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tblName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->left_col), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_left_col = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->right_col), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_right_col = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
join__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Join_ * this_object = JOIN_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Join_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rowName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->rowName, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tblName", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->tblName, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "left_col", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->left_col), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "right_col", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->right_col), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
join__set_property (GObject *object,
                    guint property_id,
                    const GValue *value,
                    GParamSpec *pspec)
{
  Join_ *self = JOIN_ (object);

  switch (property_id)
  {
    case PROP_JOIN__ROW_NAME:
      if (self->rowName != NULL)
        g_free (self->rowName);
      self->rowName = g_value_dup_string (value);
      self->__isset_rowName = TRUE;
      break;

    case PROP_JOIN__TBL_NAME:
      if (self->tblName != NULL)
        g_free (self->tblName);
      self->tblName = g_value_dup_string (value);
      self->__isset_tblName = TRUE;
      break;

    case PROP_JOIN__LEFT_COL:
      if (self->left_col != NULL)
        g_object_unref (self->left_col);
      self->left_col = g_value_dup_object (value);
      self->__isset_left_col = TRUE;
      break;

    case PROP_JOIN__RIGHT_COL:
      if (self->right_col != NULL)
        g_object_unref (self->right_col);
      self->right_col = g_value_dup_object (value);
      self->__isset_right_col = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
join__get_property (GObject *object,
                    guint property_id,
                    GValue *value,
                    GParamSpec *pspec)
{
  Join_ *self = JOIN_ (object);

  switch (property_id)
  {
    case PROP_JOIN__ROW_NAME:
      g_value_set_string (value, self->rowName);
      break;

    case PROP_JOIN__TBL_NAME:
      g_value_set_string (value, self->tblName);
      break;

    case PROP_JOIN__LEFT_COL:
      g_value_set_object (value, self->left_col);
      break;

    case PROP_JOIN__RIGHT_COL:
      g_value_set_object (value, self->right_col);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
join__instance_init (Join_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->rowName = NULL;
  object->__isset_rowName = FALSE;
  object->tblName = NULL;
  object->__isset_tblName = FALSE;
  object->left_col = g_object_new (TYPE_FULL_COLUMN_NAME_, NULL);
  object->__isset_left_col = FALSE;
  object->right_col = g_object_new (TYPE_FULL_COLUMN_NAME_, NULL);
  object->__isset_right_col = FALSE;
}

static void 
join__finalize (GObject *object)
{
  Join_ *tobject = JOIN_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->rowName != NULL)
  {
    g_free(tobject->rowName);
    tobject->rowName = NULL;
  }
  if (tobject->tblName != NULL)
  {
    g_free(tobject->tblName);
    tobject->tblName = NULL;
  }
  if (tobject->left_col != NULL)
  {
    g_object_unref(tobject->left_col);
    tobject->left_col = NULL;
  }
  if (tobject->right_col != NULL)
  {
    g_object_unref(tobject->right_col);
    tobject->right_col = NULL;
  }
}

static void
join__class_init (Join_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = join__read;
  struct_class->write = join__write;

  gobject_class->finalize = join__finalize;
  gobject_class->get_property = join__get_property;
  gobject_class->set_property = join__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_JOIN__ROW_NAME,
     g_param_spec_string ("rowName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_JOIN__TBL_NAME,
     g_param_spec_string ("tblName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_JOIN__LEFT_COL,
     g_param_spec_object ("left_col",
                         NULL,
                         NULL,
                         TYPE_FULL_COLUMN_NAME_,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_JOIN__RIGHT_COL,
     g_param_spec_object ("right_col",
                         NULL,
                         NULL,
                         TYPE_FULL_COLUMN_NAME_,
                         G_PARAM_READWRITE));
}

GType
join__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Join_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) join__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Join_),
      0, /* n_preallocs */
      (GInstanceInitFunc) join__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Join_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _SelectStmt_Properties
{
  PROP_SELECT_STMT__0,
  PROP_SELECT_STMT__ROW_NAME,
  PROP_SELECT_STMT__TBL_NAME,
  PROP_SELECT_STMT__JOIN,
  PROP_SELECT_STMT__WHERE,
  PROP_SELECT_STMT__SELECT
};

/* reads a select_stmt_ object */
static gint32
select_stmt__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SelectStmt_ * this_object = SELECT_STMT_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->rowName != NULL)
          {
            g_free(this_object->rowName);
            this_object->rowName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->rowName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rowName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->tblName != NULL)
          {
            g_free(this_object->tblName);
            this_object->tblName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->tblName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tblName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->join), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_join = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->where), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->select), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_select = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
select_stmt__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SelectStmt_ * this_object = SELECT_STMT_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SelectStmt_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rowName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->rowName, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tblName", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->tblName, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_join == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "join", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->join), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->where), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "select", T_STRUCT, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->select), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
select_stmt__set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  SelectStmt_ *self = SELECT_STMT_ (object);

  switch (property_id)
  {
    case PROP_SELECT_STMT__ROW_NAME:
      if (self->rowName != NULL)
        g_free (self->rowName);
      self->rowName = g_value_dup_string (value);
      self->__isset_rowName = TRUE;
      break;

    case PROP_SELECT_STMT__TBL_NAME:
      if (self->tblName != NULL)
        g_free (self->tblName);
      self->tblName = g_value_dup_string (value);
      self->__isset_tblName = TRUE;
      break;

    case PROP_SELECT_STMT__JOIN:
      if (self->join != NULL)
        g_object_unref (self->join);
      self->join = g_value_dup_object (value);
      self->__isset_join = TRUE;
      break;

    case PROP_SELECT_STMT__WHERE:
      if (self->where != NULL)
        g_object_unref (self->where);
      self->where = g_value_dup_object (value);
      self->__isset_where = TRUE;
      break;

    case PROP_SELECT_STMT__SELECT:
      if (self->select != NULL)
        g_object_unref (self->select);
      self->select = g_value_dup_object (value);
      self->__isset_select = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
select_stmt__get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  SelectStmt_ *self = SELECT_STMT_ (object);

  switch (property_id)
  {
    case PROP_SELECT_STMT__ROW_NAME:
      g_value_set_string (value, self->rowName);
      break;

    case PROP_SELECT_STMT__TBL_NAME:
      g_value_set_string (value, self->tblName);
      break;

    case PROP_SELECT_STMT__JOIN:
      g_value_set_object (value, self->join);
      break;

    case PROP_SELECT_STMT__WHERE:
      g_value_set_object (value, self->where);
      break;

    case PROP_SELECT_STMT__SELECT:
      g_value_set_object (value, self->select);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
select_stmt__instance_init (SelectStmt_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->rowName = NULL;
  object->__isset_rowName = FALSE;
  object->tblName = NULL;
  object->__isset_tblName = FALSE;
  object->join = g_object_new (TYPE_JOIN_, NULL);
  object->__isset_join = FALSE;
  object->where = g_object_new (TYPE_COMPOUND_CONDITION_, NULL);
  object->__isset_where = FALSE;
  object->select = g_object_new (TYPE_SELECT_LIST_, NULL);
  object->__isset_select = FALSE;
}

static void 
select_stmt__finalize (GObject *object)
{
  SelectStmt_ *tobject = SELECT_STMT_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->rowName != NULL)
  {
    g_free(tobject->rowName);
    tobject->rowName = NULL;
  }
  if (tobject->tblName != NULL)
  {
    g_free(tobject->tblName);
    tobject->tblName = NULL;
  }
  if (tobject->join != NULL)
  {
    g_object_unref(tobject->join);
    tobject->join = NULL;
  }
  if (tobject->where != NULL)
  {
    g_object_unref(tobject->where);
    tobject->where = NULL;
  }
  if (tobject->select != NULL)
  {
    g_object_unref(tobject->select);
    tobject->select = NULL;
  }
}

static void
select_stmt__class_init (SelectStmt_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = select_stmt__read;
  struct_class->write = select_stmt__write;

  gobject_class->finalize = select_stmt__finalize;
  gobject_class->get_property = select_stmt__get_property;
  gobject_class->set_property = select_stmt__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SELECT_STMT__ROW_NAME,
     g_param_spec_string ("rowName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SELECT_STMT__TBL_NAME,
     g_param_spec_string ("tblName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SELECT_STMT__JOIN,
     g_param_spec_object ("join",
                         NULL,
                         NULL,
                         TYPE_JOIN_,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SELECT_STMT__WHERE,
     g_param_spec_object ("where",
                         NULL,
                         NULL,
                         TYPE_COMPOUND_CONDITION_,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SELECT_STMT__SELECT,
     g_param_spec_object ("select",
                         NULL,
                         NULL,
                         TYPE_SELECT_LIST_,
                         G_PARAM_READWRITE));
}

GType
select_stmt__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SelectStmt_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) select_stmt__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SelectStmt_),
      0, /* n_preallocs */
      (GInstanceInitFunc) select_stmt__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SelectStmt_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _UpdateStmt_Properties
{
  PROP_UPDATE_STMT__0,
  PROP_UPDATE_STMT__TBL_NAME,
  PROP_UPDATE_STMT__NEW_ROW,
  PROP_UPDATE_STMT__COND
};

/* reads a update_stmt_ object */
static gint32
update_stmt__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UpdateStmt_ * this_object = UPDATE_STMT_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tblName != NULL)
          {
            g_free(this_object->tblName);
            this_object->tblName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->tblName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tblName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ColVal_ * _elem14 = NULL;
              if ( _elem14 != NULL)
              {
                g_object_unref (_elem14);
              }
              _elem14 = g_object_new (TYPE_COL_VAL_, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem14), protocol, error)) < 0)
              {
                g_object_unref (_elem14);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->new_row, _elem14);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_new_row = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->cond), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_cond = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
update_stmt__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UpdateStmt_ * this_object = UPDATE_STMT_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UpdateStmt_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tblName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->tblName, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "new_row", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i15;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->new_row ? this_object->new_row->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i15 = 0; i15 < (this_object->new_row ? this_object->new_row->len : 0); i15++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->new_row, i15))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cond", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->cond), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
update_stmt__set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  UpdateStmt_ *self = UPDATE_STMT_ (object);

  switch (property_id)
  {
    case PROP_UPDATE_STMT__TBL_NAME:
      if (self->tblName != NULL)
        g_free (self->tblName);
      self->tblName = g_value_dup_string (value);
      self->__isset_tblName = TRUE;
      break;

    case PROP_UPDATE_STMT__NEW_ROW:
      if (self->new_row != NULL)
        g_ptr_array_unref (self->new_row);
      self->new_row = g_value_dup_boxed (value);
      self->__isset_new_row = TRUE;
      break;

    case PROP_UPDATE_STMT__COND:
      if (self->cond != NULL)
        g_object_unref (self->cond);
      self->cond = g_value_dup_object (value);
      self->__isset_cond = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
update_stmt__get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  UpdateStmt_ *self = UPDATE_STMT_ (object);

  switch (property_id)
  {
    case PROP_UPDATE_STMT__TBL_NAME:
      g_value_set_string (value, self->tblName);
      break;

    case PROP_UPDATE_STMT__NEW_ROW:
      g_value_set_boxed (value, self->new_row);
      break;

    case PROP_UPDATE_STMT__COND:
      g_value_set_object (value, self->cond);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
update_stmt__instance_init (UpdateStmt_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tblName = NULL;
  object->__isset_tblName = FALSE;
  object->new_row = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_new_row = FALSE;
  object->cond = g_object_new (TYPE_COMPOUND_CONDITION_, NULL);
  object->__isset_cond = FALSE;
}

static void 
update_stmt__finalize (GObject *object)
{
  UpdateStmt_ *tobject = UPDATE_STMT_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tblName != NULL)
  {
    g_free(tobject->tblName);
    tobject->tblName = NULL;
  }
  if (tobject->new_row != NULL)
  {
    g_ptr_array_unref (tobject->new_row);
    tobject->new_row = NULL;
  }
  if (tobject->cond != NULL)
  {
    g_object_unref(tobject->cond);
    tobject->cond = NULL;
  }
}

static void
update_stmt__class_init (UpdateStmt_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = update_stmt__read;
  struct_class->write = update_stmt__write;

  gobject_class->finalize = update_stmt__finalize;
  gobject_class->get_property = update_stmt__get_property;
  gobject_class->set_property = update_stmt__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_STMT__TBL_NAME,
     g_param_spec_string ("tblName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_STMT__NEW_ROW,
     g_param_spec_boxed ("new_row",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_STMT__COND,
     g_param_spec_object ("cond",
                         NULL,
                         NULL,
                         TYPE_COMPOUND_CONDITION_,
                         G_PARAM_READWRITE));
}

GType
update_stmt__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UpdateStmt_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) update_stmt__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UpdateStmt_),
      0, /* n_preallocs */
      (GInstanceInitFunc) update_stmt__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UpdateStmt_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _DeleteStmt_Properties
{
  PROP_DELETE_STMT__0,
  PROP_DELETE_STMT__TBL_NAME,
  PROP_DELETE_STMT__COND
};

/* reads a delete_stmt_ object */
static gint32
delete_stmt__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DeleteStmt_ * this_object = DELETE_STMT_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->tblName != NULL)
          {
            g_free(this_object->tblName);
            this_object->tblName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->tblName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tblName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->cond), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_cond = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
delete_stmt__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DeleteStmt_ * this_object = DELETE_STMT_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DeleteStmt_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tblName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->tblName, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_cond == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cond", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->cond), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
delete_stmt__set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  DeleteStmt_ *self = DELETE_STMT_ (object);

  switch (property_id)
  {
    case PROP_DELETE_STMT__TBL_NAME:
      if (self->tblName != NULL)
        g_free (self->tblName);
      self->tblName = g_value_dup_string (value);
      self->__isset_tblName = TRUE;
      break;

    case PROP_DELETE_STMT__COND:
      if (self->cond != NULL)
        g_object_unref (self->cond);
      self->cond = g_value_dup_object (value);
      self->__isset_cond = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
delete_stmt__get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  DeleteStmt_ *self = DELETE_STMT_ (object);

  switch (property_id)
  {
    case PROP_DELETE_STMT__TBL_NAME:
      g_value_set_string (value, self->tblName);
      break;

    case PROP_DELETE_STMT__COND:
      g_value_set_object (value, self->cond);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
delete_stmt__instance_init (DeleteStmt_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->tblName = NULL;
  object->__isset_tblName = FALSE;
  object->cond = g_object_new (TYPE_COMPOUND_CONDITION_, NULL);
  object->__isset_cond = FALSE;
}

static void 
delete_stmt__finalize (GObject *object)
{
  DeleteStmt_ *tobject = DELETE_STMT_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->tblName != NULL)
  {
    g_free(tobject->tblName);
    tobject->tblName = NULL;
  }
  if (tobject->cond != NULL)
  {
    g_object_unref(tobject->cond);
    tobject->cond = NULL;
  }
}

static void
delete_stmt__class_init (DeleteStmt_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = delete_stmt__read;
  struct_class->write = delete_stmt__write;

  gobject_class->finalize = delete_stmt__finalize;
  gobject_class->get_property = delete_stmt__get_property;
  gobject_class->set_property = delete_stmt__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DELETE_STMT__TBL_NAME,
     g_param_spec_string ("tblName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DELETE_STMT__COND,
     g_param_spec_object ("cond",
                         NULL,
                         NULL,
                         TYPE_COMPOUND_CONDITION_,
                         G_PARAM_READWRITE));
}

GType
delete_stmt__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DeleteStmt_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) delete_stmt__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DeleteStmt_),
      0, /* n_preallocs */
      (GInstanceInitFunc) delete_stmt__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DeleteStmt_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _Stmt_Properties
{
  PROP_STMT__0,
  PROP_STMT__CREATE_TBL,
  PROP_STMT__DROP_TBL,
  PROP_STMT__INSERT,
  PROP_STMT__SELECT,
  PROP_STMT__UPDATE,
  PROP_STMT__DL
};

/* reads a stmt_ object */
static gint32
stmt__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Stmt_ * this_object = STMT_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->create_tbl), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_create_tbl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->drop_tbl), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_drop_tbl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->insert), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_insert = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->select), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_select = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->update), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_update = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->dl), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_dl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
stmt__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Stmt_ * this_object = STMT_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Stmt_", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_create_tbl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "create_tbl", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->create_tbl), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_drop_tbl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "drop_tbl", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->drop_tbl), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_insert == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "insert", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->insert), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_select == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "select", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->select), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_update == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "update", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->update), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_dl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "dl", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->dl), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
stmt__set_property (GObject *object,
                    guint property_id,
                    const GValue *value,
                    GParamSpec *pspec)
{
  Stmt_ *self = STMT_ (object);

  switch (property_id)
  {
    case PROP_STMT__CREATE_TBL:
      if (self->create_tbl != NULL)
        g_object_unref (self->create_tbl);
      self->create_tbl = g_value_dup_object (value);
      self->__isset_create_tbl = TRUE;
      break;

    case PROP_STMT__DROP_TBL:
      if (self->drop_tbl != NULL)
        g_object_unref (self->drop_tbl);
      self->drop_tbl = g_value_dup_object (value);
      self->__isset_drop_tbl = TRUE;
      break;

    case PROP_STMT__INSERT:
      if (self->insert != NULL)
        g_object_unref (self->insert);
      self->insert = g_value_dup_object (value);
      self->__isset_insert = TRUE;
      break;

    case PROP_STMT__SELECT:
      if (self->select != NULL)
        g_object_unref (self->select);
      self->select = g_value_dup_object (value);
      self->__isset_select = TRUE;
      break;

    case PROP_STMT__UPDATE:
      if (self->update != NULL)
        g_object_unref (self->update);
      self->update = g_value_dup_object (value);
      self->__isset_update = TRUE;
      break;

    case PROP_STMT__DL:
      if (self->dl != NULL)
        g_object_unref (self->dl);
      self->dl = g_value_dup_object (value);
      self->__isset_dl = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
stmt__get_property (GObject *object,
                    guint property_id,
                    GValue *value,
                    GParamSpec *pspec)
{
  Stmt_ *self = STMT_ (object);

  switch (property_id)
  {
    case PROP_STMT__CREATE_TBL:
      g_value_set_object (value, self->create_tbl);
      break;

    case PROP_STMT__DROP_TBL:
      g_value_set_object (value, self->drop_tbl);
      break;

    case PROP_STMT__INSERT:
      g_value_set_object (value, self->insert);
      break;

    case PROP_STMT__SELECT:
      g_value_set_object (value, self->select);
      break;

    case PROP_STMT__UPDATE:
      g_value_set_object (value, self->update);
      break;

    case PROP_STMT__DL:
      g_value_set_object (value, self->dl);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
stmt__instance_init (Stmt_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->create_tbl = g_object_new (TYPE_CREATE_STMT_, NULL);
  object->__isset_create_tbl = FALSE;
  object->drop_tbl = g_object_new (TYPE_DROP_STMT_, NULL);
  object->__isset_drop_tbl = FALSE;
  object->insert = g_object_new (TYPE_INSERT_STMT_, NULL);
  object->__isset_insert = FALSE;
  object->select = g_object_new (TYPE_SELECT_STMT_, NULL);
  object->__isset_select = FALSE;
  object->update = g_object_new (TYPE_UPDATE_STMT_, NULL);
  object->__isset_update = FALSE;
  object->dl = g_object_new (TYPE_DELETE_STMT_, NULL);
  object->__isset_dl = FALSE;
}

static void 
stmt__finalize (GObject *object)
{
  Stmt_ *tobject = STMT_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->create_tbl != NULL)
  {
    g_object_unref(tobject->create_tbl);
    tobject->create_tbl = NULL;
  }
  if (tobject->drop_tbl != NULL)
  {
    g_object_unref(tobject->drop_tbl);
    tobject->drop_tbl = NULL;
  }
  if (tobject->insert != NULL)
  {
    g_object_unref(tobject->insert);
    tobject->insert = NULL;
  }
  if (tobject->select != NULL)
  {
    g_object_unref(tobject->select);
    tobject->select = NULL;
  }
  if (tobject->update != NULL)
  {
    g_object_unref(tobject->update);
    tobject->update = NULL;
  }
  if (tobject->dl != NULL)
  {
    g_object_unref(tobject->dl);
    tobject->dl = NULL;
  }
}

static void
stmt__class_init (Stmt_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = stmt__read;
  struct_class->write = stmt__write;

  gobject_class->finalize = stmt__finalize;
  gobject_class->get_property = stmt__get_property;
  gobject_class->set_property = stmt__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_STMT__CREATE_TBL,
     g_param_spec_object ("create_tbl",
                         NULL,
                         NULL,
                         TYPE_CREATE_STMT_,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STMT__DROP_TBL,
     g_param_spec_object ("drop_tbl",
                         NULL,
                         NULL,
                         TYPE_DROP_STMT_,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STMT__INSERT,
     g_param_spec_object ("insert",
                         NULL,
                         NULL,
                         TYPE_INSERT_STMT_,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STMT__SELECT,
     g_param_spec_object ("select",
                         NULL,
                         NULL,
                         TYPE_SELECT_STMT_,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STMT__UPDATE,
     g_param_spec_object ("update",
                         NULL,
                         NULL,
                         TYPE_UPDATE_STMT_,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STMT__DL,
     g_param_spec_object ("dl",
                         NULL,
                         NULL,
                         TYPE_DELETE_STMT_,
                         G_PARAM_READWRITE));
}

GType
stmt__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Stmt_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) stmt__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Stmt_),
      0, /* n_preallocs */
      (GInstanceInitFunc) stmt__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Stmt_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _Statement_Properties
{
  PROP_STATEMENT__0,
  PROP_STATEMENT__ST_TYPE,
  PROP_STATEMENT__STMT
};

/* reads a statement_ object */
static gint32
statement__read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Statement_ * this_object = STATEMENT_(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast16;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->st_type = (QueryType_)ecast16;
          this_object->__isset_st_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->stmt), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_stmt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
statement__write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Statement_ * this_object = STATEMENT_(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Statement_", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "st_type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->st_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stmt", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->stmt), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
statement__set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  Statement_ *self = STATEMENT_ (object);

  switch (property_id)
  {
    case PROP_STATEMENT__ST_TYPE:
      self->st_type = g_value_get_int (value);
      self->__isset_st_type = TRUE;
      break;

    case PROP_STATEMENT__STMT:
      if (self->stmt != NULL)
        g_object_unref (self->stmt);
      self->stmt = g_value_dup_object (value);
      self->__isset_stmt = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
statement__get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  Statement_ *self = STATEMENT_ (object);

  switch (property_id)
  {
    case PROP_STATEMENT__ST_TYPE:
      g_value_set_int (value, self->st_type);
      break;

    case PROP_STATEMENT__STMT:
      g_value_set_object (value, self->stmt);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
statement__instance_init (Statement_ * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_st_type = FALSE;
  object->stmt = g_object_new (TYPE_STMT_, NULL);
  object->__isset_stmt = FALSE;
}

static void 
statement__finalize (GObject *object)
{
  Statement_ *tobject = STATEMENT_ (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->stmt != NULL)
  {
    g_object_unref(tobject->stmt);
    tobject->stmt = NULL;
  }
}

static void
statement__class_init (Statement_Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = statement__read;
  struct_class->write = statement__write;

  gobject_class->finalize = statement__finalize;
  gobject_class->get_property = statement__get_property;
  gobject_class->set_property = statement__set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_STATEMENT__ST_TYPE,
     g_param_spec_int ("st_type",
                       NULL,
                       NULL,
                       0,
                       5,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STATEMENT__STMT,
     g_param_spec_object ("stmt",
                         NULL,
                         NULL,
                         TYPE_STMT_,
                         G_PARAM_READWRITE));
}

GType
statement__get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Statement_Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) statement__class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Statement_),
      0, /* n_preallocs */
      (GInstanceInitFunc) statement__instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Statement_Type",
                                   &type_info, 0);
  }

  return type;
}

enum _ServerResponseProperties
{
  PROP_SERVER_RESPONSE_0,
  PROP_SERVER_RESPONSE_INFO,
  PROP_SERVER_RESPONSE_ROWS,
  PROP_SERVER_RESPONSE_STATUS
};

/* reads a server_response object */
static gint32
server_response_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServerResponse * this_object = SERVER_RESPONSE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->info != NULL)
          {
            g_free(this_object->info);
            this_object->info = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->info, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_info = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GPtrArray * _elem17 = g_ptr_array_new_with_free_func (g_object_unref);
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  ColVal_ * _elem18 = NULL;
                  if ( _elem18 != NULL)
                  {
                    g_object_unref (_elem18);
                  }
                  _elem18 = g_object_new (TYPE_COL_VAL_, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem18), protocol, error)) < 0)
                  {
                    g_object_unref (_elem18);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (_elem17, _elem18);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              g_ptr_array_add (this_object->rows, _elem17);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast19;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast19, error)) < 0)
            return -1;
          xfer += ret;
          this_object->status = (Status_)ecast19;
          this_object->__isset_status = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
server_response_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServerResponse * this_object = SERVER_RESPONSE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServerResponse", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "info", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->info, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rows", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i20;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_LIST, (gint32) (this_object->rows ? this_object->rows->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i20 = 0; i20 < (this_object->rows ? this_object->rows->len : 0); i20++)
    {
      {
        guint i21;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->rows, i20)) ? ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->rows, i20))->len : 0), error)) < 0)
          return -1;
        xfer += ret;
        for (i21 = 0; i21 < (((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->rows, i20)) ? ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->rows, i20))->len : 0); i21++)
        {
          if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) ((GPtrArray*)g_ptr_array_index ((GPtrArray *) this_object->rows, i20)), i21))), protocol, error)) < 0)
            return -1;
          xfer += ret;

        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "status", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->status, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
server_response_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  ServerResponse *self = SERVER_RESPONSE (object);

  switch (property_id)
  {
    case PROP_SERVER_RESPONSE_INFO:
      if (self->info != NULL)
        g_free (self->info);
      self->info = g_value_dup_string (value);
      self->__isset_info = TRUE;
      break;

    case PROP_SERVER_RESPONSE_ROWS:
      if (self->rows != NULL)
        g_ptr_array_unref (self->rows);
      self->rows = g_value_dup_boxed (value);
      self->__isset_rows = TRUE;
      break;

    case PROP_SERVER_RESPONSE_STATUS:
      self->status = g_value_get_int (value);
      self->__isset_status = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
server_response_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  ServerResponse *self = SERVER_RESPONSE (object);

  switch (property_id)
  {
    case PROP_SERVER_RESPONSE_INFO:
      g_value_set_string (value, self->info);
      break;

    case PROP_SERVER_RESPONSE_ROWS:
      g_value_set_boxed (value, self->rows);
      break;

    case PROP_SERVER_RESPONSE_STATUS:
      g_value_set_int (value, self->status);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
server_response_instance_init (ServerResponse * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->info = NULL;
  object->__isset_info = FALSE;
  object->rows = g_ptr_array_new_with_free_func ((GDestroyNotify) g_ptr_array_unref);
  object->__isset_rows = FALSE;
  object->__isset_status = FALSE;
}

static void 
server_response_finalize (GObject *object)
{
  ServerResponse *tobject = SERVER_RESPONSE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->info != NULL)
  {
    g_free(tobject->info);
    tobject->info = NULL;
  }
  if (tobject->rows != NULL)
  {
    g_ptr_array_unref (tobject->rows);
    tobject->rows = NULL;
  }
}

static void
server_response_class_init (ServerResponseClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = server_response_read;
  struct_class->write = server_response_write;

  gobject_class->finalize = server_response_finalize;
  gobject_class->get_property = server_response_get_property;
  gobject_class->set_property = server_response_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVER_RESPONSE_INFO,
     g_param_spec_string ("info",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVER_RESPONSE_ROWS,
     g_param_spec_boxed ("rows",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVER_RESPONSE_STATUS,
     g_param_spec_int ("status",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));
}

GType
server_response_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServerResponseClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) server_response_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServerResponse),
      0, /* n_preallocs */
      (GInstanceInitFunc) server_response_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServerResponseType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _SendStatement_serviceExecuteStmtArgsProperties
{
  PROP_SEND_STATEMENT_SERVICE_EXECUTE_STMT_ARGS_0,
  PROP_SEND_STATEMENT_SERVICE_EXECUTE_STMT_ARGS_STATEMENT
};

/* reads a send_statement_service_execute_stmt_args object */
static gint32
send_statement_service_execute_stmt_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SendStatement_serviceExecuteStmtArgs * this_object = SEND_STATEMENT_SERVICE_EXECUTE_STMT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->statement), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_statement = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
send_statement_service_execute_stmt_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SendStatement_serviceExecuteStmtArgs * this_object = SEND_STATEMENT_SERVICE_EXECUTE_STMT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SendStatement_serviceExecuteStmtArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "statement", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->statement), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
send_statement_service_execute_stmt_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  SendStatement_serviceExecuteStmtArgs *self = SEND_STATEMENT_SERVICE_EXECUTE_STMT_ARGS (object);

  switch (property_id)
  {
    case PROP_SEND_STATEMENT_SERVICE_EXECUTE_STMT_ARGS_STATEMENT:
      if (self->statement != NULL)
        g_object_unref (self->statement);
      self->statement = g_value_dup_object (value);
      self->__isset_statement = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
send_statement_service_execute_stmt_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  SendStatement_serviceExecuteStmtArgs *self = SEND_STATEMENT_SERVICE_EXECUTE_STMT_ARGS (object);

  switch (property_id)
  {
    case PROP_SEND_STATEMENT_SERVICE_EXECUTE_STMT_ARGS_STATEMENT:
      g_value_set_object (value, self->statement);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
send_statement_service_execute_stmt_args_instance_init (SendStatement_serviceExecuteStmtArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->statement = g_object_new (TYPE_STATEMENT_, NULL);
  object->__isset_statement = FALSE;
}

static void 
send_statement_service_execute_stmt_args_finalize (GObject *object)
{
  SendStatement_serviceExecuteStmtArgs *tobject = SEND_STATEMENT_SERVICE_EXECUTE_STMT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->statement != NULL)
  {
    g_object_unref(tobject->statement);
    tobject->statement = NULL;
  }
}

static void
send_statement_service_execute_stmt_args_class_init (SendStatement_serviceExecuteStmtArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = send_statement_service_execute_stmt_args_read;
  struct_class->write = send_statement_service_execute_stmt_args_write;

  gobject_class->finalize = send_statement_service_execute_stmt_args_finalize;
  gobject_class->get_property = send_statement_service_execute_stmt_args_get_property;
  gobject_class->set_property = send_statement_service_execute_stmt_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SEND_STATEMENT_SERVICE_EXECUTE_STMT_ARGS_STATEMENT,
     g_param_spec_object ("statement",
                         NULL,
                         NULL,
                         TYPE_STATEMENT_,
                         G_PARAM_READWRITE));
}

GType
send_statement_service_execute_stmt_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SendStatement_serviceExecuteStmtArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) send_statement_service_execute_stmt_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SendStatement_serviceExecuteStmtArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) send_statement_service_execute_stmt_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SendStatement_serviceExecuteStmtArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _SendStatement_serviceExecuteStmtResultProperties
{
  PROP_SEND_STATEMENT_SERVICE_EXECUTE_STMT_RESULT_0,
  PROP_SEND_STATEMENT_SERVICE_EXECUTE_STMT_RESULT_SUCCESS
};

/* reads a send_statement_service_execute_stmt_result object */
static gint32
send_statement_service_execute_stmt_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SendStatement_serviceExecuteStmtResult * this_object = SEND_STATEMENT_SERVICE_EXECUTE_STMT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
send_statement_service_execute_stmt_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SendStatement_serviceExecuteStmtResult * this_object = SEND_STATEMENT_SERVICE_EXECUTE_STMT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SendStatement_serviceExecuteStmtResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
send_statement_service_execute_stmt_result_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  SendStatement_serviceExecuteStmtResult *self = SEND_STATEMENT_SERVICE_EXECUTE_STMT_RESULT (object);

  switch (property_id)
  {
    case PROP_SEND_STATEMENT_SERVICE_EXECUTE_STMT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
send_statement_service_execute_stmt_result_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  SendStatement_serviceExecuteStmtResult *self = SEND_STATEMENT_SERVICE_EXECUTE_STMT_RESULT (object);

  switch (property_id)
  {
    case PROP_SEND_STATEMENT_SERVICE_EXECUTE_STMT_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
send_statement_service_execute_stmt_result_instance_init (SendStatement_serviceExecuteStmtResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_SERVER_RESPONSE, NULL);
  object->__isset_success = FALSE;
}

static void 
send_statement_service_execute_stmt_result_finalize (GObject *object)
{
  SendStatement_serviceExecuteStmtResult *tobject = SEND_STATEMENT_SERVICE_EXECUTE_STMT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
send_statement_service_execute_stmt_result_class_init (SendStatement_serviceExecuteStmtResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = send_statement_service_execute_stmt_result_read;
  struct_class->write = send_statement_service_execute_stmt_result_write;

  gobject_class->finalize = send_statement_service_execute_stmt_result_finalize;
  gobject_class->get_property = send_statement_service_execute_stmt_result_get_property;
  gobject_class->set_property = send_statement_service_execute_stmt_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SEND_STATEMENT_SERVICE_EXECUTE_STMT_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_SERVER_RESPONSE,
                         G_PARAM_READWRITE));
}

GType
send_statement_service_execute_stmt_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SendStatement_serviceExecuteStmtResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) send_statement_service_execute_stmt_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SendStatement_serviceExecuteStmtResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) send_statement_service_execute_stmt_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SendStatement_serviceExecuteStmtResultType",
                                   &type_info, 0);
  }

  return type;
}

